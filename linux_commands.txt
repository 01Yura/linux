root@291417:~# - Если в начале строки символ #, это значит что мы работаем из под root
yura@291417:~$ - значок $ значит из под обычного пользователя
type команда - показывает что это: всроенная в системная команда , алиас или бинарный файл
whereis команда - показывают абсолютный путь до команды исполнителя

Как запускается команда. Сначала система ищет встроена ли она в оболочку (cd), если не находит, то ищет в алиасах (ls), если и там нет, то по порядку ищет в окружении (переменная $PATH, она хранится в памяти)
    yura@291417:~$ type cd
    cd is a shell builtin
    yura@291417:~$ type ls
    ls is aliased to `ls --color=auto'
    yura@291417:~$ type mkdir
    mkdir is /usr/bin/mkdir
    yura@291417:~$ echo $PATH
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    Порядок директорий в $PATH задан в файле home/пользователь/.profile

    alias ll="ls -lai --color=auto"
    alias grep="grep --color=always"


    Хэширование команд
    yura@291417:~$ hash
hits    command
   2    /usr/bin/whereis
   2    /usr/bin/nano
   1    /usr/bin/rm
   2    /usr/bin/ls
    Баш один раз смотрит где файл и потом им пользуется
    hash -r - для очистки хэша 



cd директория - переместиться в директорию
    cd -- - вернуться в предыдущую директорию 
    cd ~ - перейти в домашний каталог (можно просто cd без всего)
    cd -   перейти в директортю в которой были до этого и вышли
ls -la - отобразить содержимое директории с правами (-l) и скрытыми файлами (-a) 
    ls -li - отобразить номера inode (файловый дескриптор=inode)
    alias ll="ls --color=auto -a -i -l" - алиас для ls -lai
cat файл - отобразить содержимое файла
touch файл - создать файл (по факту сменить время)
less файл - просмотреть файл с возможностью листать
mkdir директория - создать директорию
mkdir -p dir1/dir2/dir3 - создать одну в другой и в той еще одну
rmdir - удалить пустую директорию
rm -r директория - удалить даже не пустую директорию
УДАЛЕНИЕ определяется правом на каталог в котором находится файл, а не правами на файл. Если у вас есть права на запись на каталог, то вы можете удалить все файлы, которые в нем (удалить инфу об айнодах если точнее)
tput reset ^M - чтобы закрыть случайно открытый бинарник в терминале.
cp -r какую_директорию куда - скорировать диреторию (не важно какую)
yura@291417:~$ who - кто сейчас нп сераеое, с каеого ip
yura     pts/0        2023-05-01 01:50 (88.241.51.147)

uname -a - инфа о системе

apt dist-upgrade - обновляет системные файлы, докачивая или удаляя, если без dist, то обновятся      только установленные пакеты
apt remove название_программы - удаляет программу без конфигов
apt purge название_программы - удаляет и программу и конфиги
apt search ключевое_слово - ищет программу в репозиториях по слову
apt autoremove - удаляет зависимости уже удаленных программ
apt autoclean - удалить старые архиыные файлы
apt install -f - если сломались зависимости например при обновлении
apt edit-sources - редактировать файл sources.list
neofetch - утилита информации о системе красивая

systemctl status процесс - показать статус процесса
    systemctl stop/start процесс- запустить/остановить процесс
systemctl enable/disable программа - вкл или выкл из автозагрузки
systemctl reload программа - перезагрущить программу 

apropos слово - ищет описание по ключевому слову 
    apropos -s 1 passwd - найти утилиту смены пароля
    Обратите внимание на число в скобках после имени команды. Это глава или раздел справочного руководства man, в которых может встречаться описание утилиты. Разделов много, приведем самые полезные: 
●	1 — команды пользователя, 
●	2 — системные вызовы ядра (используется программистами), 
●	5 — форматы файлов, 
●	8 — команды администрирования.
whatis команда - выводит инфу о команде
man команда - справка о команде
    /слово - поиск конкретного слова в справке (следующее - n)
find ./ -name "название файла" - икать в корневой директоррии файл
grep -rin --include="*.py" "фраза" . - ищем фразу "фраза" рекурсивно (r) внутри всех файлов .py в текущей директории без учета регистра (i) и с указанием номера строки (n)
ripgrep (rg) -i "фраза" - по умолчанию раьотает в рекурсивном режиме



/etc/passwd - здесь хранится инфа о пользователях (тут можно сменить домашний каталог)
/etc/group - инфа о группах
/etc/shadow - инфа о паролях

id имя_пользоватля - инфа о uid, gid
аутентификация - проверка существования пользователя и пароля
авторизация - проверка ваших прав на какие-либо действия
adduser имя - добавть юзера
adduser существующий_юзер группа - добавить юзера в группу
sha256 - secure hash algoritm это хэш функция
chmod u/g/o-/+r/w/x файл - изменить права user group or other + or - read write executable, например 
    chmod o+x файл, если не указать никого то права изменятся у пользователя и у группы
    chmod -R 750 каталог - задать данные права на все все файлы в каталоге и каталог
    Надичие t-бита у каталога означает, что только владелец может удалять и переименовывать файлы (+t)
Права доступа для директорий
    Атрибут x даёт доступ к inode и на чтение, и на запись. Если атрибут x снят, файл невозможно ни изменить, ни прочитать из-за невозможности получить доступ к атрибутам.
Если у директории нет права на чтение, вы не сможете посмотреть ее оглавление. Но если знаете имя файла, сможете его посмотреть, явным образом указав его по имени.

> файл- стандартный поток вывода в файл (работает справа налево)
2> файл - стандартный поток ошибок файл
>> файл - перезаписать файл

ll asdf . 1> file 2>&1 - записать в file и STDOUT и STDERR (& - амперсанд это указатель) Сначала поток 1 будет перенаправлен в file, а затем поток 2 будет перенаправлен туда же куда и поток 1

ll asdf . 1> STDOUT 2> STDERR - записать в один файл поток ввода, а в другой поток ошибок

ll asdf . 2>&1 | grep слово_для_поиска - второй поток мы перенаправляем в первый, а первый в grep. Поэтому grep найдет и ошибки и норм информацию, смотря от запроса

ll asdf . 2>&1 1> /dev/null | grep слово_для_поиска - перенаправляем в grep только стандартный поток ошибок

echo $? - показывает код выполнения последней команды (0 или не 0)




Данные хранятся на диске. Информация о том где именно на диске хранятся эти данные + права + размер + время создания файла (записи информации на диск  и т.д. хранится в айноде. И эта айнода имеет назавание для нашего удобства - имя файла. Таким образом файл это просто именованная область данных на диске. Ядро обращается к информации по номеру айноды.
Вся информация о файлах в каталоге (директории) хранится в этом же каталоге. В каталоге как в библиотеке. Таким образом каталог это просто файл с информацией. С одной стороны написано имя, а с другой номер айноды. В линукс всё есть файл.


hard link - это просто имя файла в данном каталоге
ln test test_hl - создание хард линка для файла тест (ln что_линкую куда_линкую)
В каталоге в столбике отображается количество хард-линков на файл:
    root@291417:~# ls -li
    total 32
    12605 -rw-r--r-- 1 root root     1 Aug 19  2019 lsblk_raw
    3362 -rw-r--r-- 1 root root 18563 Apr 23 19:31 test-docker.sh
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test_hl  - вот хард линк, айнода 5285 и как у оригинала
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test.txt

stat имя_файла - отображает инфу из айноды

 ln -s test.txt test_sl - создать софт линк
    root@291417:~# ls -li
    total 36
    5264 -rw-r--r-- 1 root root   523 Apr 24 23:50 copy_text.txt
    12605 -rw-r--r-- 1 root root     1 Aug 19  2019 lsblk_raw
    3362 -rw-r--r-- 1 root root 18563 Apr 23 19:31 test-docker.sh
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test_hl
    10556 lrwxrwxrwx 1 root root     8 Apr 24 23:57 test_sl -> test.txt - вот это софт линк
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test.txt

suid бит нужен чтоюы мы могли внести изменения в файл, к которому у нас нет доступа. Например изменить свой пароль (если вы не рут) в файле /etc/shadow
-rwsr-xr-x 1 root root 63736 Jul 27  2018 /usr/bin/passwd - этот бинарный файл является командой для смены пароля пользователя, который хранится в /etc/shadow
Если будет запущен этот файл /usr/bin/passwd, то владелец процесса будет равен владельцу этого файла. Те файл запускается от имени своего владельца, а не от имени того кто его запустил. Это благодаря suid биту.
Установить SUID можно с помощью команды:
chmod u+s myfile


chown - смена владельца файла 
ps aux - отображает процессы пользовательского пространства и потоки ядра (отображаются в квадратных скобках)
    ps -T -p 4242 - xтобы посмотреть потоки, используйте ключ -T, если хотите посмотреть потоки конкретного процесса, используйте ключ -p
top и htop - утилиты мониторинга процессов

kill -15 PID_процесса
kill -9 PID_процесса - завершить процесс. 
    ●	9 (SIGKILL) — безусловное завершение программы. Сигнал не может быть перехвачен программой, потому позволяет её остановить в любом случае (но не позволит снять процесс-зомби). 
    15 (SIGTERM) — вежливая просьба программе завершить работу. Программа может сохранить данные и т.д.
nice -n 10 название процусса - понизить приоритет процесса
ps aux - отобразить все процессы с колонкой юзеры
pstree - дерево процессов

 tar xvf архивный_файл куда_извлечь - разархивировать архив .tar

Если вам попался пакет rpm (для систем типа Fedora, Mandriva, SUSE и т.д.), его можно сконвертировать в deb с помощью утилиты alien (устанавливается отдельно). Однако делать это рекомендуется лишь в исключительных случаях, когда пакетов deb в доступе нет (например драйверы принтеров Canon на официальном сайте выложены исключительно в rpm).

tar -xvzf архив.tar.gz -C папка_в_которую_надо_разархивировать
    x — дозволяет вам извлекать файлы из архива.
    v — делает вывод tar подробным. Это означает, что на экран будут выведены все выисканные в архиве файлы. Если эта опция опущена, информация, выводимая в процессе обработки, станет ограничена.
    f — является обязательной опцией. Без неё tar пытается использовать магнитную ленту вместо файла картотеки.
    z — позволяет вам обрабатывать архив, сжатый gzip’ом (с расширением .gz). Если вы забудете указать эту функцию, tar выдаст ошибку. И наоборот, эта опция не должна использоваться для несжатых архивов.
 
 unzip архив.zip - разархивировать архив .zip

 Установка программ с собственным инсталлятором
    INSTALL.sh. Если этот файл не захочет запускаться, вероятно, ему не даны права на запуск. Иногда дистрибутив программы распространяется в виде самораспаковывающегося архива. В таком случае это будет просто один-единственный файл .sh, который нужно запустить.
Установка программ из исходных текстов
    Основное, что понадобится — средства для компиляции, для этого сначала нужно установить пакет build­-essential. Дальше нужно распаковать архив с кодами программы во временную папку. Потом нужно найти файл README или INSTALL, прочитать его и выполнить то, что там написано. Чаще установка программ таким способом ограничивается последовательным выполнениям следующих команд:
    ./configure 
    make
    sudo make install
Файл .deb
    dpkg -i имя_пакета.deb
Snap
    snap install название_программы



 Системный список репозиториев содержится в файле /etc/apt/sources.list. Чтобы добавить репозиторий,­     отредактируйте файл так:
    sudo nano /etc/apt/sources.list

    Добавьте туда APT-строку. Чем «выше» (ближе к началу файла) стоит строка, тем больший приоритет получит добавленный репозиторий.
    Далее следует обновить список пакетов. Для этого выполните:
    sudo apt­-get update

    sudo apt­-key add ключ_репозитория.key - добавление ключа репозитория

Для хранения логов предусмотрена директория /var/log
Общесистемные логи, как правило, хранятся в файле /var/log/syslog (или в /var/log/messages, например в Centos)
Сообщения ядра хранятся в /var/log/dmesg

tail -f /var/log/syslog - показывает последние строки по мере их появления
tail файл - выводит последние 10 строк
    - n кол-во_строк - показать количество строк
head файл - выводит первые 10 строк

Для запуска системных утилит и других программ служит командный интерпретатор или, как его еще называют, оболочка (shell), основной инструмент системного администратора Linux. Интерпретатор — своего рода язык программирования, позволяющий создавать сложные сценарии (скрипты), также он используется интерактивно для последовательного ввода команд.

cat файл1 файл2 - считывает данные из файлов и выводит их содержимое файлов в единый поток
wc - считает еоличество строк, символов и т.д.

SELinux — система с принудительным контролем доступа. Сложна в настройке, но позволяет с ювелирной точностью настроить те системы, которым критична безопасность

id имя_пользоватля - показывает инфу о пользователе
usermod -aG sudo имя_пользователя - добавить пользователя в группу судо, сли убрать ключ -а, то пользователь выйдет из всех остальных групп

oga@uho:~$ ls -lL /dev/cdrom 
    brw-rw----+ 1 root cdrom 11, 0 июня   1 13:33 /dev/cdrom                                
    Видно, что права на чтение и запись имеют пользователи, которые входят в группу cdrom.
    Обратите внимание на признак блочного устройства в первой позиции атрибутов. 
    Плюс в конце строчки прав означает, что используются ACL, можно их посмотреть командой getfacl. 

                              Создание пользователей и групп
Создадим группу developer:
# groupadd developer

Создадим двух пользователей — ivanov и petrov:
# useradd -m -G developer -s /bin/bash ivanov
# useradd -m -G developer -s /bin/bash petrov

Мы использовали опции: 
-m — также создать домашний каталог. По умолчанию каталог создаётся в /home с именем учётной записи, например, /home/ivanov. Если надо создать нестандартный каталог, можно указать его, используя параметр параметра -d. 
-G — список групп, к которым принадлежит создаваемый пользователь. По умолчанию также создается персональная группа пользователя с именем учётной записи. Она является первичной и по умолчанию все файлы пользователя создаются с этой группой в качестве группы-владельца. 
-s — задает оболочку пользователя. Для обычных пользователей обычно это /bin/bash. Для ftp/sftp-пользователей и системных псевдопользователей на этом месте указывается псевдооболочка, например, /usr/sbin/nologin или /bin/false. 
Иногда бывает полезным указать номер пользовательского ID явным образом с помощью параметра -u : например, -u 1001. Это бывает полезным, если у вас несколько систем с одинаковыми учетными записями и вы хотите, чтобы при переносе файлов на флешке между ними, у файлов был один владелец. Для этого надо следить, чтобы на системах одинаковые пользователи имели один UID. То же самое для групп: у groupadd есть параметр -g для указания GID. 
По умолчанию для новых учетных записей без пароля заблокирован вход в систему, поэтому установим пароль для пользователей с помощью passwd, например:
# passwd petrov

Есть альтернативный способ создания пользователя.
# adduser yura

Предложит несколько вопросов, ответив на которые, мы полностью сконфигурируем будущего пользователя, в том числе и его пароль.
Если нам понадобится изменить параметры для уже созданного пользователя, поможет утилита usermod. Параметры аналогичны утилите useradd. Также её можно использовать для блокировки/разблокировки пользователей. Опция -L позволит заблокировать учётную запись. Операция блокировки добавляет символ «!» в начало пароля в файле /etc/shadow. Параметр -U снимает блокировку. Для удаления учётной записи предназначена утилита userdel. Полезный ключ -r удаляет из системы домашний каталог пользователя. 

usermod -a -G sudo yura - добавить (-а) пользователя Юра в группу (-G) sudo
deluser yura sudo - удалить пользователя Юра из группы sudo



Регулярные выражения 
    ip a | grep -P '([0-9a-f]{2}:){5}[0-9a-f]{2}' - для поиска мак-адреса
    ip address | grep --colour=always -P "((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})" - для ip адреса
    ip address | grep -P "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" - или такое

    . - любой символ
    .* - любой символ сколько угодно раз
    ^ - начало строки
    & - конец строки
    ? - означает что предыдущий символ встречается 0 или 1 раз
    [^1-5] - символ ^ в начале диапазона, означает "все кроме"

    BASH 
    echo $? - показывает код возврата последней команды (0 или не 0). Эта переменная хранит последний код возврата. Названия переменных начинаются со знака $.
    В BASH правда (true) это - 0
                    false - не 0
    команда1 && команда2 - если команда1 завершилась корректно (код возврата 0), то начать выпонять команду2. Это логическое И.
    команда1 || команда2 - логическое ИЛИ. Если команда1 отработает корректно, то 2 не будет стартовать, а если не отработает корректно, то будет.
    команда1 ; команда 2 - выполнять все команды вне зависимости от того как они выполнились. Это логическое НЕ ИМЕЕТ ЗНАЧЕНИЯ
    
    for year in {2015..2020}; do echo $year; for month in {01..12}; do echo $month; done; done

    КРОН 
     /etc/crontab - общий КРОН

     # Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )

*/2 - каждые 2 минуты
* 2 * * * * - каждую минуту как стукнет 2 часа ночи (потому что крон запускается раз в минуту)
1 2 * * * * - вот правильный вариант
01 02 * * * - или так тоже правильно

crontab -e - редактировать свой локальный кронтаб_файл 


МОНТИРОВАНИЕ

mount /dev/sda /mnt - примонтировать что и куда
df -h - выводит информацию о примонтированных устройствах
umount /mnt - откуда отмонтировать
umount /dev/sda - что отмонтировать
lsblk - вывести инфу о блочных устройствах (что куда примонтировано)
/proc/self/mounts - файл содержащий информацию о точках монтироваия
/etc/fstab - файл описывающий точки монтирования при старте Основное